#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

/*	
	整型：char short int long
	浮点型：float double 
	构造类型： 数组  结构体 struct  枚举 enum   联合 union
	指针类型
	空类型：void
*/
//void test(void) // ()里面是空的话不接受参数，但是放入void明确表示不接收参数
//{
//	printf("1");
//}
//int main()
//{
//	test(100);
//	return 0;
//}

// *************整型在内存中的存储
//int main()
//{
//	int a = 20;
//	// 00000000000000000000000000010100 - 原码
//	// 00000000000000000000000000010100 - 反码
//	// 00000000000000000000000000010100 - 补码
//	// 0x00000014   内存中是十六进制 内存中是14 00 00 00
//	int b = -10; 
//	// 10000000000000000000000000001010 - 原码
//	// 11111111111111111111111111110101 - 反码
//	// 1111 1111 1111 1111 1111 1111 1111 0110 - 补码
//	// 0xFFFFFFF6   十六进制  内存中是 f6 ff ff ff
//	return 0;
//}

//int main()
//{
//	1 - 1;
//	// 1 + (-1)
//	// 00000000000000000000000000000001  1的原码
//	// 10000000000000000000000000000001  -1的原码
//	// 10000000000000000000000000000010  原码相加的结果是错误的
//	// 用补码相加
//	// 11111111111111111111111111111111  1的补码
//	// 11111111111111111111111111111111  -1的补码
//	//100000000000000000000000000000000  只能存储32位，最高位的1抹掉
//	return 0;
//}
// 大端存储模式：数据的低位保存在内存的高地址中，数据高位保存在内存的低地址中
// 小端存储模式：数据的地位保存在内存的低地址中，数据高位保存在内存的高地址中

// 写一段代码，判断当前机器的字节序是什么
int check_sys()
{
	int a = 1; // 小端-01 00 00 00  大端-00 00 00 01
	char* p = (char*)&a; // 我们只需要第一个字节看看是不是01，所以转换成char *
	return *p; // 返回1 小端，  返回0 大端
//	return *(char*)&a;  上面两句也可以写成这样
//}
// 指针类型的意义：
// 1.指针类型决定了指针解引用操作符能访问几个字节：char*p; *p访问1个字节   int*p; *p访问4个字节
// 2.指针类型决定了指针+1，-1，加的或者减的是几个字节  char* p;p+1 跳过一个字符 int*p p+1跳过一个整型4个字节
int main()
{
	int ret = check_sys();
	if (ret == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}

// 判断打印结果
//int main()
//{
//	char a = -1;
//	// 10000000000000000000000000000001
//	// 11111111111111111111111111111110
//	// 11111111111111111111111111111111
//	// 内存中存储的是11111111  要%d打印整型，需要进行整型提升，11111111111111111111111111111111 再转成原码就是-1
//	signed char b = -1;
//	// 和char a 一样
//	unsigned char c = -1;
//	// 内存中存的是  11111111
//	// 无符号数 最高位不是符号位 整型提升补0  
//	// 00000000000000000000000011111111
//	// 正数的原反补相同
//	printf("a = %d\nb = %d\nc = %d\n",a,b,c);
//
//	return 0;
//}

int main()
{
	char a = -128;
	// 10000000000000000000000010000000
	// 11111111111111111111111101111111
	// 11111111111111111111111110000000
	// 10000000
	// 11111111111111111111111110000000 整型提升
	// 因为是 %u 打印，内存中就是无符号数，那原反补相同
	printf("%u\n", a); // %d打印十进制的有符号数字。%u打印十进制的无符号数字
	return 0;
}