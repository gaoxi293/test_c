#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//int main()
//{
//	int i = -20;
//	// 10000000000000000000000000010100
//	// 11111111111111111111111111101011
//	// 11111111111111111111111111101100
//	unsigned int j = 10;
//	// 00000000000000000000000000001010
//	// 11111111111111111111111111110110   相加的结果
//	// 10000000000000000000000000001010   原码
//	printf("%d\n",i+j);
//	return 0;
//}

//#include <windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n",i);
//		Sleep(100);
//	}
//	return 0;
//}

// 结果为255，  char里面存放的是 -128到127
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d",strlen(a));// 字符串长度是找\0，\0的ASCII码值为0.那现在我们就找0
//	return 0;
//}

// 死循环    i恒<=255
//unsigned char i = 0;// 0-255
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//}

// ***********************浮点型在内存中的的存储
// 科学计数法  1E10=1.0*10^10
//int main()
//{
//	double d = 1E10;
//	printf("%lf\n",d);
//	return 0;
//}

// 分析的打印结果是 9  9.000000  9            9.000000
 //实际结果为       9  0.000000  1091567616   9.000000
// 浮点型和整型的存储方式是不一样的
int main()
{
	int n = 9;
	// 00000000000000000000000000001001  n的原反补
	float* pFloat = (float*)&n;
	// 0 00000000 00000000000000000001001  把n看作浮点数，内存中的序列
	// E为全0，(-1)^0 * 0.00000000000000000001001 * 2^(-126)  结果就为0.000000
	printf("n的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);

	*pFloat = 9.0;
	// 1001.0
	// 1.001 * 2^3
	// (-1)^0 * 1.001 * 2^3
	// 0 10000010 00100000000000000000000  内存中的存入浮点数9.0
	// 01000001000100000000000000000000  打印n 把浮点数的二进制序列看成整数的序列  补码
	// 01000001000100000000000000000000 原反补
	printf("num的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);
	return 0;
}

//int main()
//{
//	float f = 5.5;
//	// 5.5
//	// 101.1
//	// (-1)^0 * 1.011 * 2^2
//	// S = 0  M = 1.011  指数 E = 2
//	// 最高位表示正负  2要加上中间数127  后面补全23位
//	// 0 (2+127) 10000001 01100000000000000000000
//	// 0100 0000 1011 0000 0000 0000 0000 0000
//	// 0x40b00000
//	return 0;
//}

// ****************浮点型的存储和打印方式
/*
浮点型数字表示成为下面的形式：
(-1)^S * M * 2^E
(-1)^s表示符号位，当s=0，为整数；当s=1，为负数
M表示有效数字，>=1 ,<2
2^E表示指数位

9.0
1001.0
(-1)^0 * 1.001 * 2^3
S = 0   M = 1.001  E = 3

32位的浮点数，最高位的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M
64位的浮点数，最高位的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
内存中保存M时，M的第一位总是1，因此只保存后面的小数部分，比如保存1.01时，只保存01，读取的时候再补上
E为一个无符号整数，如果E为8位，取值范围为0-255，如果为11位，取值范围为0-2047，但是科学计数法中可以出现负数
所以我们存入E时要加上一个中间数，如果是8位，就加上127
比如 0.5 的二进制为 0.1   (-1)^0 * 1.0 * 2^(-1) S = 0  M = 1.0  E = -1,当存入内存时，E = -1+127 = 126

取出E时又分为3种情况：
1.不全为0或者不全为1  减去中间数127
2.全为0  规定真实的E为-126 ，M不再加上第一位的1，而是还原为0.xxx的小数 表示趋于0
3.全为1  表示正负无穷大
*/