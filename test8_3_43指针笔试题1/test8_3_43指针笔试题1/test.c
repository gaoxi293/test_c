#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1); // 数组地址+1 跳过整个数组
//	printf("%d,%d\n", *(a+1),*(ptr-1));  // ptr类型是int*  ptr-1向前移动一个就是5
//	//                   2       5
//	return 0;
//}


//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
//
//// 假设p 的值为0x100000。如下表达式的值分别为多少？
//// 已知，结构体Test类型的变量大小是20个字节
//
//int main()
//{
//	p = (struct Test*)0x100000;
//	printf("%p\n", p + 0x1);// p +1 +多少取决于p的类型，p是结构体 大小为20个字节 0x100014
//	printf("%p\n", (unsigned long)p + 0x1);// 0x100000转换成十进制是1048576 + 1 = 1048577  0x100001
//	printf("%p\n", (unsigned int*)p + 0x1);// +4 0x100004
//
//	return 0;
//}


//int main()
//{
//	/*
//	a 在内存中存储的是 01 00 00 00   02 00 00 00   03 00 00 00   04 00 00 00 
//	&a是整个数组的地址，+1跳到最后 ptr1[-1] == *(ptr1+(-1)) == *(ptr1 -1) 就指向04
//	a的地址转成int 再 +1 就指向 01后面的00的位置 此时ptr2解引用就访问 00 00 00 02
//	小端存储，那我们打印的就是02 00 00 00 十六进制就是0x02000000
//	*/
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);// a是首元素地址，再强转成整数，再+1
//	printf("%x  %x",ptr1[-1],*ptr2); // %x打印十六进制的十进制数字
// 
//	return 0;
//}


//int main()
//{
//	/*
//	数组里面是逗号表达式 (0,1),(2,3),(4,5) 分别存储的是1 3 5      1  3
//	a[0]是第一行的数组名，代表首元素地址					      5  0
//	p[0] == *(p+0)												  0  0
//	*/
//	int a[3][2] = { (0,1),(2,3),(4,5) };
//	int* p;
//	p = a[0];
//	printf("%d",p[0]);
//
//	return 0;
//}


//int main()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a; // p的类型是 int (*)[4]    a的类型是int (*)[5]  会有警告 但是p还是数组首元素即数组第一行的地址
//	printf("%p,%d\n",&p[4][2] - &a[4][2],&p[4][2] - &a[4][2]);
//	/*
//		a	   a[0]        a[1]       a[2]        a[3]       a[4]
//		_ _ _ _ _   _ _ _ _ _  _ _ _ _ _   _ _ _ _ _   _ _ _ _ _
//	   |	   |							|             
//	   p	  p+1						   p+4
//	p 是指向整型元素的指针，有四个元素，p+1就跳过四个整型
//	p[4][2]就相当于  *(*(p+4)+2)  *(p+4)相当于p+4往后4个整型的一个数组，相当于拿到了数组名，相当于首元素地址
//	*(*(p+4)+2) 拿到了a[3]里面的第四个元素     &p[4][2] - &a[4][2] = -4
//	%d 打印的就是原码 也就是-4   %p打印地址  直接把补码拿出来当成地址  FFFFFFFC
//	10000000 00000000 00000000 00000100   原
//	11111111 11111111 11111111 11111011   反
//	11111111 11111111 11111111 11111100   补
//	  F  F     F  F     F  F     F   C
//	*/
//
//	return 0;
//}


//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//
//	int* ptr1 = (int*)(&aa + 1);
//	int* ptr2 = (int*)(*(aa + 1));
//
//	printf("%d,%d\n", *(ptr1 - 1),*(ptr2 - 1));
//	/*
//	   1   2   3   4   5        内存中应该是1 2 3 4 5 6 7 8 9 10  一行连续存放的 写成2行只是方便理解
//	   6   7   8   9   10   
//	   &aa 代表的是整个数组的地址     aa代表的是首元素也就是第一行的地址 *(aa+1)指向6
//	*/
//	return 0;
//}

//  ******************************************   为什么*(a+1) == a[1]    **********************
//int main()
//{
//	int arr[10] = { 1,2,3,4,5 };
//	int* p = arr;
//	*(p + 2);// 就是拿到第三个元素  也就是arr[2]  即 *(p+2) == *(arr+2) == arr[2]
//	// 即使写成 arr[2] 编译器计算的时候也是先拿到数组名arr 再+2 再解引用 
//	return 0;
//}


//int main()
//{
//	char* a[] = { "work","at","alibaba"};
//	char** pa = a;
//	pa++;
//	printf("%s\n", *pa);
//
//	/*
//	a[] 里面存放的是3个字符串首字符的地址
//	a    char*  "work" 
//	     char*  "at"
//	     char*  "alibaba"
//	char** pa = a    数组名a 里面存放的是首元素的地址 就是 "work"的地址，  
//	pa 是一个指针变量，里面存放的是a的地址，类型是char** a的类型是char* ，存放a的地址的类型就是char**
//	比如 int* p   p+1就跳过一个int  那么这里的pa++ 就相当于跳过一个char*， 指向第二个char* 就是指向"at"对应的
//	char*   再解引用就是 输出at
//	*/
//	return 0;
//}


int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST"};
	char** cp[] = { c + 3, c + 2, c + 1, c};
	char*** cpp = cp;

	printf("%s\n", **++cpp);
	printf("%s\n", *--*++cpp + 3);
	printf("%s\n", *cpp[-2] + 3);
	printf("%s\n", cpp[-1][-1] + 1);

	/*
		cpp		 cp	         c
				c + 3	   char*  "ENTER"
				c + 2      char*  "NEW"
			    c + 1      char*  "POINT"
			    c          char*  "FIRST"
	++cpp 存的是 c+2 处的地址 c+2 存的是 "POINT" 首字母 P 的地址 ，即 打印 "POINT"；
	*--*++cpp+3  先执行++cpp，此时cpp指向的是c + 1，*++cpp之后得到 c + 1，再执行-- 得到c 再解引用，得到ENTER的
	首字母E的地址 +3 得到 E的地址，即打印ER；
	*cpp[-2] + 3 == *(*(cpp-2)) + 3,cpp指向c+1，cpp-2指向c+3，解引用得到 c + 3 
	再解引用得到"FIRST"的首字母F的地址，+3，打印ST； !!!!! 这一步的cpp[-2]没有像++cpp那样把cpp = cpp + 1
	cpp[-1][-1] + 1 == *(cpp-1)[-1] + 1 == *(*(cpp-1)-1) + 1 ,cpp指向 c + 1 ,cpp-1指向c+2，解引用拿到c+2，再-1
	拿到c+1，解引用得到"NEW"的地址，+1打印EW
	*/

	return 0;
}